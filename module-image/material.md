#### Glide的缓存

内存缓存
磁盘缓存

以上两种缓存使用的的算法原理都是LRU 底层是LinkedHashMap（FIFO 最近最少使用，从队列中移除）

内存缓存：
正在使用的图片缓存 ----> HashMap 持有该缓存的弱引用
真正的内存缓存

缓存key的计算
 View的宽和高 图片的Url地址或者File的地址和其他关键key -----> key

 有时候服务端图片换了，但是我们显示的图片没有更换，是因为 图片的url没变，我们使用glide加载的时候就直接用缓存了。

 当图片第一次加载的时候，回缓存到磁盘中，下次使用这张图片的时候，不再从网络上加载这个图片，而是先从内存查找，如果内存中不存在就从硬盘加载 同时会在
 内存中缓存一份，内存要快于磁盘，

 内存缓存也提供API让我们开启和禁用了

 当我们上下滑动页面的时候，划出屏幕之前的会从 resorce缓存中移除，在此使用的时候会从 内存中加载。

 为什么 资源缓存使用 HashMap 而 内存使用了 LinkedHashMap
 访问效率
 LinkedHashMap设置了访问顺序 在访问效率上没有HashMap快

 防止内存泄漏
 HashMap持有的是 弱引用 LinkedHashMap是强引用

 磁盘缓存

 缓存策略

ALL：既缓存原始图片，也缓存转换过后的图片。
NONE：不缓存任何内容。
DATA：只缓存原始图片。
RESOURCE：只缓存转换过后的图片。
AUTOMATIC：默认策略，它会尝试对本地和远程图片使用最佳的策略。如果是远程图片，则只缓存原始图片；如果是本地图片，那么只缓存转换过后的图片。

资源类型
仅仅缓存转换后的图片

数据缓存
仅仅缓存原始图片

资源类型（Resource）与数据来源（Data）中存储缓存的步骤我都是利用缓存 Key 去反推得出数据是哪里缓存的
